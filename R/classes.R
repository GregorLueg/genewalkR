# classes ----------------------------------------------------------------------

## GeneWalk class --------------------------------------------------------------

#' GeneWalk
#'
#' @description
#' Class that stores keeps all of the important data for the Gene Walk
#' algorithm, see Ietswaart, et al. The class can be subsequently used for to
#' apply the Gene Walk algorithm.
#'
#' @section Properties:
#' \describe{
#'   \item{graph_dt}{A data.table that contains the initial graph.}
#'   \item{gene_to_pathway_dt}{A data.table that contains the gene to pathway
#'   connections.}
#'   \item{gene_ids}{The genes represented in your gene walk list.}
#'   \item{pathway_ids}{The pathways represented in your gene walk network.}
#'   \item{embd}{The initial embedding matrix generated by node2vec on top of
#'   the graph.}
#'   \item{permuted_embd}{A list containing the permuted versions of the graph
#'   data for subsequent statistical testing.}
#'   \item{stats}{A data.table containing the information on the statistical
#'   testing across the permutations.}
#'   \item{params}{A list in which used parameters will be stored.}
#' }
#'
#' @param graph_dt A data.table with the graph information. Needs to have
#' the columns `"from"`, `"to"` and `"type"`; type must include `"hierarchy"`
#' for the pathways, `"interaction"` for interactions and `"part_of"` for
#' gene/pathway interactions, and optionally a weight.
#' @param gene_to_pathway_dt A data.table with the gene to pathway information.
#' Needs to have `"from"` (gene) and `"to"` (pathway).
#' @param gene_ids String. The "bag of genes" you are testing.
#' @param pathway_ids String. The pathways represented in the network.
#'
#' @return Returns the initialised GeneWalk initialised object for subsequent
#' analysis.
#'
#' @export
#'
#' @references Ietswaart, et al., Genome Biol, 2021
GeneWalk <- S7::new_class(
  # name
  name = "GeneWalk",
  # properties
  properties = list(
    graph_dt = S7::class_data.frame,
    gene_to_pathway_dt = S7::class_data.frame,
    gene_ids = S7::class_character,
    pathway_ids = S7::class_character,
    embd = S7::class_numeric,
    permuted_embd = S7::class_list,
    stats = S7::class_data.frame,
    params = S7::class_list
  ),
  # constructor
  constructor = function(graph_dt, gene_to_pathway_dt, gene_ids, pathway_ids) {
    # checks
    checkGeneWalkGraphDt(graph_dt)
    assertGeneWalkDataTable(gene_to_pathway_dt)
    checkmate::qassert(gene_ids, "S+")
    checkmate::qassert(pathway_ids, "S+")

    empty_emb <- matrix()
    storage.mode(empty_emb) <- "numeric"

    # need to add empty objects for S7 to behave
    S7::new_object(
      S7::S7_object(),
      graph_dt = graph_dt,
      gene_to_pathway_dt = gene_to_pathway_dt,
      gene_ids = gene_ids,
      pathway_ids = pathway_ids,
      embd = empty_emb,
      permuted_embd = list(),
      stats = data.table(),
      params = list()
    )
  }
)

### methods --------------------------------------------------------------------

#### print ---------------------------------------------------------------------

#' @name print.GeneWalk
#' @title print Method for GeneWalk object
#'
#' @description
#' Print a GeneWalk object.
#'
#' @param x An object of class GeneWalk
#' @param ... Additional arguments (currently not used).
#'
#' @returns Invisibly returns x.
#'
#' @method print GeneWalk
S7::method(print, GeneWalk) <- function(x, ...) {
  n_edges <- nrow(x@graph_dt)
  embd_generated <- nrow(x@embd) > 1 || ncol(x@embd) > 1
  perm_generated <- length(x@permuted_embd) > 0
  stats_calculated <- nrow(x@stats) > 0
  gene_ids <- x@gene_ids
  no_genes <- length(gene_ids)
  if (no_genes >= 3) {
    gene_ids <- gene_ids[1:3]
  }

  cat("GeneWalk\n")
  cat(
    "  Represented genes",
    paste(gene_ids, collapse = " | "),
    sprintf("; Total of %i genes.", no_genes),
    "\n"
  )
  cat("  Number of edges:", n_edges, "\n")
  cat("  Embedding generated:", ifelse(embd_generated, "yes", "no"), "\n")
  cat("  Permutations generated:", ifelse(perm_generated, "yes", "no"), "\n")
  cat("  Statistics calculated:", ifelse(stats_calculated, "yes", "no"), "\n")

  invisible(x)
}

#### getters -------------------------------------------------------------------

#' Get the statistical results
#'
#' @param object The `GeneWalk` class, please see
#' [genewalkR::GeneWalk()].
#'
#' @returns If found, the GeneWalk statistics results
#'
#' @export
get_stats <- S7::new_generic(
  name = "get_stats",
  dispatch_args = "object",
  fun = function(
    object
  ) {
    S7::S7_dispatch()
  }
)

#' @method get_stats GeneWalk
#'
#' @export
S7::method(get_stats, GeneWalk) <- function(
  object
) {
  # checks
  checkmate::assertTRUE(S7::S7_inherits(object, GeneWalk))

  stats <- S7::prop(object, "stats")

  if (nrow(stats) == 0) {
    warning(paste(
      "It does not like the calculate_genewalk_stats() was run.",
      "Returning empty data.table"
    ))
    return(data.table())
  }

  data.table::setorder(stats, -similarity)

  return(stats)
}

#' Get the embedding
#'
#' @param object The `GeneWalk` class, please see [genewalkR::GeneWalk()].
#'
#' @returns If found, returns the embedding
#'
#' @export
get_embedding <- S7::new_generic(
  name = "get_embedding",
  dispatch_args = "object",
  fun = function(
    object
  ) {
    S7::S7_dispatch()
  }
)

#' @method get_embedding GeneWalk
#'
#' @export
S7::method(get_embedding, GeneWalk) <- function(
  object
) {
  # checks
  checkmate::assertTRUE(S7::S7_inherits(object, GeneWalk))

  embd <- S7::prop(object, "embd")

  if (is.na(embd[1, 1])) {
    warning(paste(
      "It does not like the generate_initial_emb() was run.",
      "Returning matrix with NA."
    ))
  }

  return(embd)
}

#' Get the edge data.table
#'
#' @param object The `GeneWalk` class, please see [genewalkR::GeneWalk()].
#'
#' @returns Returns the edge data.table stored in the object
#'
#' @export
get_graph_dt <- S7::new_generic(
  name = "get_graph_dt",
  dispatch_args = "object",
  fun = function(
    object
  ) {
    S7::S7_dispatch()
  }
)

#' @method get_graph_dt GeneWalk
#'
#' @export
S7::method(get_graph_dt, GeneWalk) <- function(
  object
) {
  # checks
  checkmate::assertTRUE(S7::S7_inherits(object, GeneWalk))

  graph_dt <- S7::prop(object, "graph_dt")

  return(graph_dt)
}

#' Get the gene to pathway data.table
#'
#' @param object The `GeneWalk` class, please see [genewalkR::GeneWalk()].
#'
#' @returns Returns the gene to pathway data.table stored in the object
#'
#' @export
get_gene_pathway_dt <- S7::new_generic(
  name = "get_gene_pathway_dt",
  dispatch_args = "object",
  fun = function(
    object
  ) {
    S7::S7_dispatch()
  }
)

#' @method get_gene_pathway_dt GeneWalk
#'
#' @export
S7::method(get_gene_pathway_dt, GeneWalk) <- function(
  object
) {
  # checks
  checkmate::assertTRUE(S7::S7_inherits(object, GeneWalk))

  gene_to_pathway_dt <- S7::prop(object, "gene_to_pathway_dt")

  return(gene_to_pathway_dt)
}

## DataBuilder -----------------------------------------------------------------

#' Generate a new DataBuilder helper class
#'
#' @param ppis data.table. The full interaction data to subset subsequently.
#' @param gene_to_pathways data.table. The gene to pathway associations.
#' @param pathway_hierarchy data.table. The pathway ontology
#'
#' @returns Returns the initialised `DataBuilder` object.
#'
#' @export
new_data_builder <- function(ppis, gene_to_pathways, pathway_hierarchy) {
  # checks
  assertGeneWalkDataTable(ppis)
  assertGeneWalkDataTable(gene_to_pathways)
  assertGeneWalkDataTable(pathway_hierarchy)

  all_nodes <- unique(c(
    ppis %$% c(from, to),
    gene_to_pathways %$% c(from, to),
    pathway_hierarchy %$% c(from, to)
  ))

  res <- list(
    ppis = ppis,
    gene_to_pathways = gene_to_pathways,
    pathway_hierarchy = pathway_hierarchy,
    n_edges = nrow(ppis) + nrow(gene_to_pathways) + nrow(pathway_hierarchy),
    n_nodes = length(all_nodes),
    all_nodes = all_nodes
  )

  class(res) <- "DataBuilder"

  return(res)
}

### methods --------------------------------------------------------------------

#### general -------------------------------------------------------------------

#' Dimensions of a DataBuilder object
#'
#' @param x A `DataBuilder` object.
#'
#' @returns An integer vector of length 2, where the first element is the total
#'   number of edges across all tables and the second element is `NA`.
#'
#' @export
dim.DataBuilder <- function(x) {
  c(x$n_edges, NA_integer_)
}

#' Number of nodes represented
#'
#' @param x An object from which to get the number of nodes.
#'
#' @return Number of unique nodes stored in the class.
#'
#' @export
n_nodes <- function(x) {
  UseMethod("n_nodes")
}

#' @rdname n_nodes
#'
#' @export
n_nodes.DataBuilder <- function(x) {
  x$n_nodes
}

#### getters -------------------------------------------------------------------

#' Get the filtered GW data for a list of genes
#'
#' @param x An object from which to extract the genewalk data
#' @param gene_ids String. The gene ids to which to filter the data.
#'
#' @returns A list with the following elements
#' \itemize{
#'   \item gwn - The final GeneWalk network.
#'   \item genes_to_pathways - The genes to pathway information.
#'   \item represented_genes - All included genes.
#'   \item represented_pathways - All included pathways.
#' }
#'
#' @export
get_gw_data_filtered <- function(x, gene_ids) {
  UseMethod("get_gw_data_filtered")
}

#' @rdname get_gw_data_filtered
#'
#' @export
#'
#' @importFrom magrittr `%>%`
#' @importFrom magrittr `%$%`
get_gw_data_filtered.DataBuilder <- function(x, gene_ids) {
  # checks
  checkmate::assertClass(x, "DataBuilder")
  checkmate::qassert(gene_ids, "S+")

  ppi_red <- x$ppi[, c("from", "to")][from %in% gene_ids & to %in% gene_ids][,
    type := "interaction"
  ]
  genes_to_pathways <- x$gene_to_pathways[, c("from", "to")][
    from %in% gene_ids
  ][,
    type := "part_of"
  ]
  pathways_hierarchy <- x$pathway_hierarchy[, c("from", "to")][,
    type := "hierarchy"
  ]

  combined_data <- data.table::rbindlist(list(
    ppi_red,
    genes_to_pathways,
    pathways_hierarchy
  )) %>%
    unique()

  # extract the represented pathways
  represented_genes <- unique(c(
    ppi_red %$% c(from, to),
    genes_to_pathways$from
  ))
  represented_pathways <- unique(c(
    genes_to_pathways$to,
    pathways_hierarchy %$% c(from, to)
  ))

  res <- list(
    gwn = combined_data,
    genes_to_pathways = genes_to_pathways,
    represented_genes = represented_genes,
    represented_pathways = represented_pathways
  )
}

#' Get the full GW data stored in the class
#'
#' @param x An object from which to extract the genewalk data.
#'
#' @returns A data.table with the full data stored in the class.
#'
#' @export
get_gw_data <- function(x) {
  UseMethod("get_gw_data")
}

#' @rdname get_gw_data
#'
#' @export
get_gw_data.DataBuilder <- function(x) {
  # checks
  checkmate::assertClass(x, "DataBuilder")

  ppi_red <- x$ppi[, c("from", "to")][,
    type := "interaction"
  ]
  genes_to_pathways <- x$gene_to_pathways[, c("from", "to")][,
    type := "part_of"
  ]
  pathways_hierarchy <- x$pathway_hierarchy[, c("from", "to")][,
    type := "hierarchy"
  ]

  combined_data <- data.table::rbindlist(list(
    ppi_red,
    genes_to_pathways,
    pathways_hierarchy
  )) %>%
    unique()

  combined_data
}

## gene walk generator ---------------------------------------------------------

#' Gene Walk Network Generator
#'
#' @description
#' R6 class to build Gene Walk networks from internal database sources.
#' Supports building a master network once and subsetting to multiple gene sets.
#'
#' @export
GeneWalkGenerator <- R6::R6Class(
  # name
  classname = "GeneWalkGenerator",
  # public methods/fields
  public = list(
    #' @field pathway_sources Character vector of pathway sources
    pathway_sources = NULL,
    #' @field pathway_namespaces List of namespace filters per pathway source
    pathway_namespaces = NULL,
    #' @field ppi_sources Character vector of PPI sources
    ppi_sources = NULL,
    #' @field ppi_params List of PPI filtering parameters
    ppi_params = NULL,

    #' @description Initialise the generator
    initialize = function() {
      self$pathway_sources <- character(0)
      self$pathway_namespaces <- list()
      self$ppi_sources <- character(0)
      self$ppi_params <- list()
    },

    #' @description Print for GeneWalkGenerator
    #'
    #' @param ... Additional parameters to forward to the print
    print = function(...) {
      cat("GeneWalkGenerator\n")

      cat(
        "  Added pathway sources:",
        if (length(self$pathway_sources) > 0) {
          paste(self$pathway_sources, collapse = ", ")
        } else {
          "none"
        },
        "\n"
      )

      cat(
        "  Added PPI sources:",
        if (length(self$ppi_sources) > 0) {
          paste(self$ppi_sources, collapse = ", ")
        } else {
          "none"
        },
        "\n"
      )

      if (length(self$pathway_namespaces) > 0) {
        ns_text <- vapply(
          names(self$pathway_namespaces),
          function(nm) {
            paste0(
              nm,
              " (",
              paste(self$pathway_namespaces[[nm]], collapse = ", "),
              ")"
            )
          },
          character(1)
        )
        cat(
          "  Pathway namespace constraints:",
          paste(ns_text, collapse = "; "),
          "\n"
        )
      } else {
        cat("  Pathway namespace constraints: none\n")
      }

      if (length(self$ppi_params) > 0) {
        param_text <- paste(
          names(self$ppi_params),
          self$ppi_params,
          sep = " = ",
          collapse = ", "
        )
        cat("  PPI params:", param_text, "\n")
      } else {
        cat("  PPI params: none\n")
      }

      cat(
        "  Network generated:",
        ifelse(is.null(self$network_dt), "no", "yes"),
        "\n"
      )

      invisible(self)
    },

    #' @description Add pathway sources to the network
    #'
    #' @param source Character vector of sources: `"go"`, `"reactome"`. Defaults
    #' to `"go"` only by default.
    #' @param go_namespace Character vector. Specifically for GO. Choices
    #' are `c("biological_process", "molecular_function", "cellular_component")`
    add_pathways = function(
      source = c("go", "reactome"),
      go_namespace = c(
        "biological_process",
        "molecular_function",
        "cellular_component"
      )
    ) {
      # checks
      checkmate::checkTRUE(all(source %in% c("go", "reactome")))
      checkmate::checkTRUE(all(
        source %in%
          c(
            "biological_process",
            "molecular_function",
            "cellular_component"
          )
      ))

      # multi match
      source <- match.arg(source)
      self$pathway_sources <- union(self$pathway_sources, source)

      if ("go" %in% source) {
        go_namespace <- match.arg(go_namespace, several.ok = TRUE)
        self$pathway_namespaces$go <- union(
          self$pathway_namespaces$go,
          go_namespace
        )
      }
      invisible(self)
    },

    #' @description Add PPI sources to the network
    #'
    #' @param source Character vector of sources
    #' @param string_threshold Numeric threshold for STRING scores
    #' @param intact_threshold Numeric threshold for Intact scores
    #' @param intact_physical_only Logical, only physical interactions from
    #' Intact
    add_ppi = function(
      source = c("combined", "string", "signor", "reactome", "intact"),
      string_threshold = NULL,
      intact_threshold = NULL,
      intact_physical_only = FALSE
    ) {
      source <- match.arg(source)

      checkmate::assertChoice(
        source,
        c("combined", "string", "signor", "reactome", "intact")
      )
      checkmate::qassert(string_threshold, c("0", "N1[0, 1]"))
      checkmate::qassert(intact_threshold, c("0", "N1[0, 1]"))
      checkmate::qassert(intact_physical_only, "B1")

      self$ppi_sources <- union(self$ppi_sources, source)
      self$ppi_params$string_threshold <- string_threshold
      self$ppi_params$intact_threshold <- intact_threshold
      self$ppi_params$intact_physical_only <- intact_physical_only
      invisible(self)
    },

    #' @description Build the full network from selected sources
    #'
    #' @param .verbose Boolean. Controls the verbosity of the function
    build = function(.verbose = TRUE) {
      # checks
      checkmate::qassert(.verbose, "B1")

      if (length(self$pathway_sources) == 0 && length(self$ppi_sources) == 0) {
        stop("Must add at least one pathway or PPI source")
      }

      ppi <- private$get_ppi_edges()
      genes_to_pathways <- private$get_pathway_edges()
      pathway_hierarchy <- private$get_hierarchy_edges()

      private$gene_walk_data <- new_data_builder(
        ppis = ppi,
        gene_to_pathways = genes_to_pathways,
        pathway_hierarchy = pathway_hierarchy
      )

      if (.verbose) {
        message(sprintf(
          "Built network with %d edges and %d nodes",
          nrow(private$gene_walk_data),
          n_nodes(private$gene_walk_data)
        ))
      }

      invisible(self)
    },

    #' @description Create a gene-specific GeneWalk object
    #'
    #' @param genes Character vector of gene symbols
    #'
    #' @return Returns the initialised `GeneWalk`.
    create_for_genes = function(genes) {
      checkmate::qassert(genes, "S+")

      if (is.null(private$gene_walk_data)) {
        stop("Must call $build() before creating gene-specific networks")
      }

      zeallot::`%<-%`(
        c(gwn, genes_to_pathways, represented_genes, represented_pathways),
        get_gw_data_filtered(x = private$gene_walk_data, gene_ids = genes)
      )

      GeneWalk(
        graph_dt = gwn,
        gene_to_pathway_dt = genes_to_pathways,
        gene_ids = represented_genes,
        pathway_ids = represented_pathways
      )
    },

    #' @description Resets the internal choices and erases any stored network
    #' data.
    reset_choices = function() {
      self$pathway_sources <- character(0)
      self$pathway_namespaces <- list()
      self$ppi_sources <- character(0)
      self$ppi_params <- list()
      private$gene_walk_data <- NULL
    },

    #' @description Returns the full network data.table.
    #'
    #' @return data.table with the full internal network.
    return_full_network_dt = function() {
      if (is.null(private$gene_walk_data)) {
        warning("No internal data found. You need to must call $build().")
        return(NULL)
      }
      get_gw_data(private$gene_walk_data)
    }
  ),
  # private methods/fields
  private = list(
    gene_walk_data = NULL,

    # internal helper to pull out the pathways
    get_pathway_edges = function() {
      edges <- list()

      if ("go" %in% self$pathway_sources) {
        go_edges <- get_gene_to_go()

        if (!is.null(self$pathway_namespaces$go)) {
          go_info <- get_gene_ontology_info()
          go_filtered <- go_info[
            name_space %in% self$pathway_namespaces$go,
            go_id
          ]
          go_edges <- go_edges[to %in% go_filtered]
        }

        go_edges[, edge_type := "gene_to_pathway"]
        go_edges[, source := "GO"]
        edges <- c(edges, list(go_edges))
      }

      if ("reactome" %in% self$pathway_sources) {
        r_edges <- get_gene_to_reactome()
        r_edges[, edge_type := "gene_to_pathway"]
        r_edges[, source := "Reactome"]
        edges <- c(edges, list(r_edges))
      }

      if (length(edges) == 0) {
        return(data.table::data.table())
      }
      res <- data.table::rbindlist(edges, fill = TRUE)
      res
    },

    # internal helper to pull out the ppi networks
    get_ppi_edges = function() {
      edges <- list()

      if ("string" %in% self$ppi_sources) {
        string_edges <- get_interactions_string(
          threshold = self$ppi_params$string_threshold
        )
        string_edges[, edge_type := "ppi"]
        string_edges[, source := "STRING"]
        edges <- c(edges, list(string_edges))
      }

      if ("signor" %in% self$ppi_sources) {
        signor_edges <- get_interactions_signor()
        signor_edges[, edge_type := "ppi"]
        signor_edges[, source := "SIGNOR"]
        edges <- c(edges, list(signor_edges))
      }

      if ("reactome" %in% self$ppi_sources) {
        reactome_edges <- get_interactions_reactome()
        reactome_edges[, edge_type := "ppi"]
        reactome_edges[, source := "Reactome_PPI"]
        edges <- c(edges, list(reactome_edges))
      }

      if ("intact" %in% self$ppi_sources) {
        intact_edges <- get_interactions_intact(
          threshold = self$ppi_params$intact_threshold,
          physical_interactions = self$ppi_params$intact_physical_only
        )
        intact_edges[, edge_type := "ppi"]
        intact_edges[, source := "Intact"]
        edges <- c(edges, list(intact_edges))
      }

      if ("combined" %in% self$ppi_sources) {
        combined_edges <- get_interactions_combined()
        combined_edges[, edge_type := "ppi"]
        combined_edges[, source := "Combined"]
        edges <- c(edges, list(combined_edges))
      }

      if (length(edges) == 0) {
        return(data.table::data.table())
      }
      res <- data.table::rbindlist(edges, fill = TRUE)[,
        c("from", "to", "source"),
        with = FALSE
      ]

      res
    },

    # internal helper to pull out the pathway ontology
    get_hierarchy_edges = function() {
      edges <- list()

      if ("go" %in% self$pathway_sources) {
        go_hier <- get_gene_ontology_hierarchy()

        if (!is.null(self$pathway_namespaces$go)) {
          go_info <- get_gene_ontology_info()
          go_filtered <- go_info[
            name_space %in% self$pathway_namespaces$go,
            go_id
          ]
          go_hier <- go_hier[from %in% go_filtered & to %in% go_filtered]
        }

        go_hier[, edge_type := "hierarchy"]
        go_hier[, source := "GO"]
        edges <- c(edges, list(go_hier))
      }

      if ("reactome" %in% self$pathway_sources) {
        r_hier <- get_reactome_hierarchy(relationship = "parent_of")
        r_hier[, edge_type := "hierarchy"]
        r_hier[, source := "Reactome"]
        edges <- c(edges, list(r_hier))
      }

      if (length(edges) == 0) {
        return(data.table::data.table())
      }

      res <- data.table::rbindlist(edges, fill = TRUE)[,
        c("from", "to", "edge_type", "source"),
        with = FALSE
      ]

      res
    }
  )
)
